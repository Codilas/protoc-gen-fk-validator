package main

import (
	fk "github.com/codilas/protoc-gen-fk-validator/fk"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			genFile(gen, f)
		}
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		return nil
	})
}

// genFile generates a .pb.fk.go file containing gRPC service definitions.
func genFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".pb.fk.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-fk-validator. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, message := range file.Messages {
		genMessage(g, file, message)
	}
}

// genMessage
func genMessage(g *protogen.GeneratedFile, f *protogen.File, m *protogen.Message) {

	// generate methods for all used types
	genTypeMethod(g, m, protoreflect.Uint32Kind, 0)
}

// genTypeMethod generates type specific methods for returning all foreign keys with relation names
func genTypeMethod[T any](g *protogen.GeneratedFile, m *protogen.Message, kind protoreflect.Kind, zeroValue T) {
	caser := cases.Title(language.English)
	g.P("// GetForeignKeys", caser.String(kind.String()), " returns all ", kind.String(), " relation names and foreign keys for this message")
	g.P("func (m *", m.GoIdent.GoName, ") GetForeignKeys", caser.String(kind.String()), "() map[string][]", kind.String(), " {")
	g.P("fkMap := map[string][]", kind.String(), "{}")
	relationMap := map[string]string{}
	for _, field := range m.Fields {
		if field.Desc.Kind() == kind {
			options := field.Desc.Options().(*descriptorpb.FieldOptions)
			relation := proto.GetExtension(options, fk.E_ForeignKey).(string)
			if relation != "" {
				if _, found := relationMap[relation]; !found {
					g.P(relation, " := make(map[", kind.String(), "]struct{})")
					relationMap[relation] = relation
				}
				if field.Desc.IsList() {
					g.P("for _, i := range m.Get", field.GoName, "() {")
					g.P("if i != ", zeroValue, " {")
					g.P(relation, "[i] = struct{}{}")
					g.P("}")
					g.P("}")
				} else {
					g.P("if m.Get", field.GoName, "() != ", zeroValue, " {")
					g.P(relation, "[m.Get", field.GoName, "()] = struct{}{}")
					g.P("}")
				}
			}
		}
	}
	g.P("")
	for k, v := range relationMap {
		g.P("for i := range ", v, " {")
		g.P("fkMap[\"", k, "\"] = append(fkMap[\"", k, "\"], i)")
		g.P("}")
	}
	g.P("")
	g.P("return fkMap")
	g.P("}")
}
